
## 1.1 View 的一些基础知识和概念
### 1.1.1 View 的位置参数
![View的位置坐标和父容器的关系](_v_images/20190619162036888_20482.png =318x)
### 1.1.2 MotionEvent 和 TouchSlop
#### 1. MotionEvent
**典型的事件类型：**
·ACTION_DOWN ： 手指刚触摸到屏幕
·ACTION_MOVE ： 手指在屏幕上移动
·ACTION_UP ： 手指离开屏幕的一瞬间
通过MotionEvent对象获取点击事件发生时的x和y坐标
```             // 获取点击事件发生的X和Y坐标
                // 返回相对于当前View的左上角的x和y坐标
                float x = event.getX();
                float y = event.getY();

                // 返回相对于手机屏幕左上角的x和y坐标
                float rawX = event.getRawX();
                float rawY = event.getRawY();
```
#### 2. TouchSlop
含义 ： 系统所能识别出的被认为是滑动的最小距离， 也就是说如果手指上滑动的距离小于该值系统将不认为你是在滑动
获取 ： `int scaledTouchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();`
对于ViewConfiguration， 是在 package android.view 中的用于获取系统中定义的例如超时，距离，大小的常量值
```/**
     * @return Distance in pixels a touch can wander before we think the user is scrolling
     */
    public int getScaledTouchSlop() {
        return mTouchSlop;
    }
```
mTouchSlop 的赋值：
```
 mTouchSlop = res.getDimensionPixelSize(
                com.android.internal.R.dimen.config_viewConfigurationTouchSlop);
```
该常量的值与设备有关，不同设备的值可能是不同的

### VelocityTracker， GestureDetector 和 Scroller
#### 1. VelocityTracker
含义：速度追踪， 追踪手指在滑动过程中的速度， 包括水平方向和竖直方向
使用 : 
```
@Override
    public boolean onTouchEvent(MotionEvent event) {

        // 在 onTouchEvent()方法中追踪当前点击事件的速度
        if (mVelocityTracker == null) {
            mVelocityTracker = VelocityTracker.obtain();
        }
        mVelocityTracker.addMovement(event);

        switch (event.getActionMasked()) {
            case MotionEvent.ACTION_DOWN:

                break;
            case MotionEvent.ACTION_MOVE:
                /**
                 * 在获取速度之前，必须先调用 computeCurrentVelocity 方法， 该方法接收单位为ms的时间参数
                 * 这里的速度指的是一段时间内手指所划过的像素， 速度可能为负值
                 */
                mVelocityTracker.computeCurrentVelocity(1000);
                int xVelocity = (int) mVelocityTracker.getXVelocity();
                int yVelocity = (int) mVelocityTracker.getYVelocity();
                Log.d("VelocityTracker", "Move xVelocity: " + xVelocity + ".........yVelocity: " + yVelocity);
                break;
            case MotionEvent.ACTION_UP:

                break;
        }

        return true;
    }

    @Override
    protected void onDetachedFromWindow() {


        if (mVelocityTracker != null) {
            // 重置并回收内存
            mVelocityTracker.clear();
            mVelocityTracker.recycle();
        }
        super.onDetachedFromWindow();
    }
```

VelocityTracker对象的获取通过保存在 **SynchronizedPool** 对象池中， 避免了每次都去创建新的对象来降低内存资源的损耗，对外通过 **obtain()** 方法获取对象
```
/**
     * Retrieve a new VelocityTracker object to watch the velocity of a
     * motion.  Be sure to call {@link #recycle} when done.  You should
     * generally only maintain an active object while tracking a movement,
     * so that the VelocityTracker can be re-used elsewhere.
     *
     * @return Returns a new VelocityTracker.
     */
    static public VelocityTracker obtain() {
        VelocityTracker instance = sPool.acquire();
        return (instance != null) ? instance : new VelocityTracker(null);
    }
```
**SynchronizedPool** 的简单使用： 
```
public class PoolClass {
    // 定义一个最大装有几个对象的对象池
    private static final Pools.SynchronizedPool<PoolClass> sPool =
            new Pools.SynchronizedPool<>(1);

    static public PoolClass obtain() {
        // 获取对象池中的数据

        /**
         *         Pool 中的方法
         *          public T acquire() {
         *             if (this.mPoolSize > 0) {
         *                 int lastPooledIndex = this.mPoolSize - 1;
         *                 T instance = this.mPool[lastPooledIndex];
         *                 this.mPool[lastPooledIndex] = null;
         *                 --this.mPoolSize;
         *                 return instance;
         *             } else {
         *                 return null;
         *             }
         *         }
         */
        PoolClass instance = sPool.acquire();
        if (instance == null) {
            return new PoolClass();
        }
        return instance;
    }

    /**
     * 清空对象
     */
    public void recycle() {
        sPool.release(this);
    }
}
```